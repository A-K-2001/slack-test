// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: rider.sql

package models

import (
	"context"
)

const createRider = `-- name: CreateRider :one
INSERT INTO rider (user_id, status, geohash, battery, vehicle_type) VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING RETURNING user_id, status, geohash, battery, vehicle_type, created_at, updated_at
`

type CreateRiderParams struct {
	UserID      string      `db:"user_id" json:"user_id"`
	Status      RiderStatus `db:"status" json:"status"`
	Geohash     string      `db:"geohash" json:"geohash"`
	Battery     int32       `db:"battery" json:"battery"`
	VehicleType VehicleType `db:"vehicle_type" json:"vehicle_type"`
}

func (q *Queries) CreateRider(ctx context.Context, arg CreateRiderParams) (Rider, error) {
	row := q.db.QueryRow(ctx, createRider,
		arg.UserID,
		arg.Status,
		arg.Geohash,
		arg.Battery,
		arg.VehicleType,
	)
	var i Rider
	err := row.Scan(
		&i.UserID,
		&i.Status,
		&i.Geohash,
		&i.Battery,
		&i.VehicleType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRiderById = `-- name: GetRiderById :one
SELECT user_id, status, geohash, battery, vehicle_type, created_at, updated_at FROM rider WHERE user_id = $1
`

func (q *Queries) GetRiderById(ctx context.Context, userID string) (Rider, error) {
	row := q.db.QueryRow(ctx, getRiderById, userID)
	var i Rider
	err := row.Scan(
		&i.UserID,
		&i.Status,
		&i.Geohash,
		&i.Battery,
		&i.VehicleType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRiders = `-- name: GetRiders :many
SELECT user_id, status, geohash, battery, vehicle_type, created_at, updated_at FROM rider
`

func (q *Queries) GetRiders(ctx context.Context) ([]Rider, error) {
	rows, err := q.db.Query(ctx, getRiders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Rider{}
	for rows.Next() {
		var i Rider
		if err := rows.Scan(
			&i.UserID,
			&i.Status,
			&i.Geohash,
			&i.Battery,
			&i.VehicleType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRiderLocation = `-- name: UpdateRiderLocation :one
UPDATE rider SET geohash = $1, battery = $2 WHERE user_id = $3 RETURNING user_id, status, geohash, battery, vehicle_type, created_at, updated_at
`

type UpdateRiderLocationParams struct {
	Geohash string `db:"geohash" json:"geohash"`
	Battery int32  `db:"battery" json:"battery"`
	UserID  string `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateRiderLocation(ctx context.Context, arg UpdateRiderLocationParams) (Rider, error) {
	row := q.db.QueryRow(ctx, updateRiderLocation, arg.Geohash, arg.Battery, arg.UserID)
	var i Rider
	err := row.Scan(
		&i.UserID,
		&i.Status,
		&i.Geohash,
		&i.Battery,
		&i.VehicleType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRiderStatus = `-- name: UpdateRiderStatus :one
UPDATE rider SET status = $2 WHERE user_id = $1 RETURNING user_id, status, geohash, battery, vehicle_type, created_at, updated_at
`

type UpdateRiderStatusParams struct {
	UserID string      `db:"user_id" json:"user_id"`
	Status RiderStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateRiderStatus(ctx context.Context, arg UpdateRiderStatusParams) (Rider, error) {
	row := q.db.QueryRow(ctx, updateRiderStatus, arg.UserID, arg.Status)
	var i Rider
	err := row.Scan(
		&i.UserID,
		&i.Status,
		&i.Geohash,
		&i.Battery,
		&i.VehicleType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
